<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>かめはめ波（YCbCr Ver）</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; font-family: sans-serif; user-select: none; touch-action: none; color: white; }
        
        /* キャンバスは背景 */
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UIレイヤー */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; z-index: 10; }
        
        /* 共通ボタンスタイル */
        button { 
            background: linear-gradient(45deg, #FFD700, #FFA500); 
            border: 3px solid #FFF; padding: 15px 50px; font-size: 24px; font-weight: 900; 
            color: #333; border-radius: 50px; cursor: pointer; margin: 15px; pointer-events: auto; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); text-shadow: 1px 1px 0px rgba(255,255,255,0.5);
        }
        button:active { transform: scale(0.95); }

        /* 画面パネル共通 */
        .screen-panel { 
            display: none; /* JSで制御 */
            flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.85); padding: 20px; border-radius: 30px; 
            border: 4px solid #00FF00; box-shadow: 0 0 30px #00FF00; margin-top: 5%; pointer-events: auto;
            width: 90%; max-width: 600px; box-sizing: border-box;
        }
        
        /* キャリブレーション画面（背景なし） */
        #calibration-screen {
            display: none; width: 100%; height: 100%;
            flex-direction: column; justify-content: space-between; align-items: center;
            padding: 40px; box-sizing: border-box;
            pointer-events: none; 
        }
        
        .calib-text {
            color: #FFF; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            background: rgba(0,0,0,0.6); padding: 15px 30px; border-radius: 50px; border: 3px solid #FFF; text-align: center;
            margin-top: 20px; pointer-events: auto;
        }
        
        h1 { color: #00FF00; font-size: clamp(40px, 10vw, 60px); margin: 0 0 20px 0; text-shadow: 0 0 10px white; font-weight: 900; text-align: center; }
        p { font-size: 18px; margin-bottom: 30px; font-weight: bold; text-align: center; }
        .score-val { font-size: 60px; color: #00FFFF; font-weight: 900; text-shadow: 0 0 20px #00FFFF; margin-bottom: 30px; }
        
        #charge-bar-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 600px; height: 30px; background: rgba(255, 255, 255, 0.2); border-radius: 15px; overflow: hidden; display: none; border: 3px solid white; }
        #charge-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #FFFF00, #FF4500); transition: width 0.1s; }
        .credit { margin-top: 20px; font-size: 12px; color: #AAA; text-align: center; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
</head>
<body>
    <div id="ui-layer">
        <div id="title-screen" class="screen-panel" style="display: flex;">
            <h1>かめはめ波</h1>
            <p>〜 佐渡ヶ島 決戦版 〜</p>
            <p style="color:#FFFF00">High Score: <span id="high-score-title">0</span></p>
            <button onclick="startCalibration()">あそぶ！</button>
            <div class="credit">音楽素材：魔王魂 / AR Spark</div>
        </div>

        <div id="calibration-screen">
            <div class="calib-text">白い枠の中にリストバンドを入れて<br>画面をタップ！</div>
            <div style="pointer-events: auto; margin-bottom: 50px;">
                <button onclick="returnToTitle()" class="secondary" style="font-size:16px; padding:10px 30px; background:#666; border:2px solid #AAA; color:white;">タイトルへ戻る</button>
            </div>
        </div>

        <div id="result-screen" class="screen-panel">
            <h1 id="result-title">おしまい！</h1>
            <div style="font-size: 20px; color:#AAA;">スコア</div>
            <div class="score-val"><span id="final-score">0</span></div>
            <button onclick="returnToTitle()">タイトルへ</button>
        </div>
        
        <div id="charge-bar-container"><div id="charge-bar"></div></div>
    </div>

    <script>
        // --- 設定 ---
        const CAM_W = 640;
        const CAM_H = 480;
        const SKIP_STEP = 4; 
        
        // ★YCbCr判定の設定
        // Y(明るさ)は無視して、Cb(青み)とCr(赤み)の距離だけで判定します
        const COLOR_DIST_THRESH = 2000; // 判定の甘さ（大きいほど甘い）

        // 画像比率 (676:369)
        const IMG_RATIO = 369 / 676; 

        // --- 変数 ---
        let video;
        let targetYCbCr = null; // ターゲット色(YCbCr)
        let trackedPos = [null, null]; // [左手, 右手]
        
        let imgWater, imgEnemy1, imgEnemy2, imgBoss, imgBossEnd;
        let bgmNormal, bgmExtra1, bgmBoss, bgmVictory;
        let soundLoaded = { normal: false, extra: false, boss: false, win: false };
        
        let balloons = [];
        let floatingTexts = []; 
        let score = 0;
        let highScore = 0;
        let timeLeft = 60;
        let gameState = 'TITLE'; 
        
        let chargeTimer = 0, isCharging = false, isFiring = false, fireTimer = 0;
        let extraTimer = 0, boss = null, bossIsDead = false;
        let hasCollectedWater = false, waterSpawned = false;
        let warningTextX = 0, needsSeparation = false;
        let osc, noiseOsc;

        // --- p5.js ロード ---
        function preload() {
            imgWater = loadImage('water.png');
            imgEnemy1 = loadImage('enemy1.png');
            imgEnemy2 = loadImage('enemy2.png');
            imgBoss = loadImage('boss.png');
            imgBossEnd = loadImage('boss_end.png');
            
            bgmNormal = loadSound('normal_bgm.mp3', () => soundLoaded.normal = true);
            bgmExtra1 = loadSound('extra1_bgm.mp3', () => soundLoaded.extra = true);
            bgmBoss = loadSound('boss_bgm.mp3', () => soundLoaded.boss = true);
            bgmVictory = loadSound('victory.mp3', () => soundLoaded.win = true);
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(RGB, 255, 255, 255, 255);
            background(0);

            let s = localStorage.getItem('kamehameha_highscore');
            if(s) highScore = parseInt(s);
            updateScoreLabels();
            
            // カメラ設定
            let constraints = {
                video: { width: {ideal: CAM_W}, height: {ideal: CAM_H} },
                audio: false
            };
            if (location.hostname.includes("github.io")) {
                constraints.video.facingMode = "user";
            }

            video = createCapture(constraints, function() { console.log("Cam OK"); });
            video.size(CAM_W, CAM_H);
            video.hide();
            
            if(video.elt) {
                video.elt.setAttribute('playsinline', '');
                video.elt.setAttribute('autoplay', '');
            }
            
            setupSounds();
        }

        function setupSounds() {
            osc = new p5.Oscillator('sine'); osc.amp(0); osc.start();
            noiseOsc = new p5.Noise('brown'); noiseOsc.amp(0); noiseOsc.start();
        }

        function ensureAudio() {
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
        }

        function updateScoreLabels() {
            let t = document.getElementById('high-score-title');
            let r = document.getElementById('high-score-result');
            if(t) t.innerText = highScore.toLocaleString();
            if(r) r.innerText = highScore.toLocaleString();
        }

        function draw() {
            background(0);
            
            // 1. カメラ描画
            if (video && video.width) {
                let scaleW = width / video.width;
                let scaleH = height / video.height;
                let vScale = max(scaleW, scaleH);
                let w = video.width * vScale;
                let h = video.height * vScale;
                let x = (width - w) / 2;
                let y = (height - h) / 2;
                
                push();
                translate(width, 0);
                scale(-1, 1);
                tint(255); // 明るさMAX
                image(video, -(x+w), y, w, h);
                pop();
                
                // 座標変換用
                window.vidScale = vScale;
                window.vidX = x;
                window.vidY = y;
            }

            // 2. ゲーム状態分岐
            if (gameState === 'CALIBRATION') {
                drawCalibrationGuide();
                processVideoYCbCr();
            } else if (['GAME', 'EXTRA1', 'EXTRA2'].includes(gameState)) {
                processVideoYCbCr(); 
                updateGameLogic();    
                drawGameObjects();
                drawGameUI(); 
            } else if (gameState === 'WARNING') {
                processVideoYCbCr();
                drawWarning();
            } else if (gameState === 'COUNTDOWN') {
                processVideoYCbCr();
                drawCountdown();
            }
        }

        // ★★★ YCbCr 色変換 & 追跡 ★★★

        // RGB -> YCbCr 変換関数
        // Y (輝度), Cb (青色差), Cr (赤色差)
        function rgbToYCbCr(r, g, b) {
            let y  =  0.299 * r + 0.587 * g + 0.114 * b;
            let cb = -0.169 * r - 0.331 * g + 0.500 * b + 128;
            let cr =  0.500 * r - 0.419 * g - 0.081 * b + 128;
            return [y, cb, cr];
        }

        function processVideoYCbCr() {
            if (!targetYCbCr || !video || video.width === 0) return;
            video.loadPixels();
            if (video.pixels.length === 0) return;
            
            let matchingPixels = [];
            for (let y = 0; y < video.height; y += SKIP_STEP) {
                for (let x = 0; x < video.width; x += SKIP_STEP) {
                    // 画面端はノイズが多いので無視
                    if (x < 10 || y < 10 || x > video.width - 10 || y > video.height - 10) continue;

                    let i = (y * video.width + x) * 4;
                    let r = video.pixels[i];
                    let g = video.pixels[i+1];
                    let b = video.pixels[i+2];
                    
                    let currentYCbCr = rgbToYCbCr(r, g, b);
                    
                    // ★判定ロジック：Y（明るさ）は無視して、CbとCrの距離だけで判定する
                    // distSq = (Cb1 - Cb2)^2 + (Cr1 - Cr2)^2
                    let d = (currentYCbCr[1] - targetYCbCr[1])**2 + (currentYCbCr[2] - targetYCbCr[2])**2;

                    if (d < COLOR_DIST_THRESH) {
                        // 画面座標に変換（左右反転）
                        let screenX = width - (window.vidX + x * window.vidScale); 
                        let screenY = window.vidY + y * window.vidScale;
                        matchingPixels.push({x: screenX, y: screenY});
                    }
                }
            }

            if (matchingPixels.length < 10) return; // ノイズなら無視
            
            // 座標のクラスタリング（左右の手）
            matchingPixels.sort((a, b) => a.x - b.x);
            let mid = Math.floor(matchingPixels.length / 2);
            
            let sumX=0, sumY=0, count=0;
            for(let i=0; i<mid; i++) { sumX += matchingPixels[i].x; sumY += matchingPixels[i].y; count++; }
            if(count > 5) trackedPos[0] = {x: sumX/count, y: sumY/count};
            
            sumX=0; sumY=0; count=0;
            for(let i=mid; i<matchingPixels.length; i++) { sumX += matchingPixels[i].x; sumY += matchingPixels[i].y; count++; }
            if(count > 5) trackedPos[1] = {x: sumX/count, y: sumY/count};
            
            // デバッグ表示（手）
            noFill(); stroke(0, 255, 0); strokeWeight(4);
            if(trackedPos[0]) circle(trackedPos[0].x, trackedPos[0].y, 50);
            if(trackedPos[1]) circle(trackedPos[1].x, trackedPos[1].y, 50);
        }

        function getAverageYCbCr() {
            if (!video || video.pixels.length === 0) return null;
            let sumR=0, sumG=0, sumB=0, count=0;
            let cx = video.width / 2; 
            let cy = video.height / 2;
            // 中央周辺の平均色を取得
            for(let dy=-10; dy<=10; dy++){
                for(let dx=-10; dx<=10; dx++){
                    let i = (floor(cy+dy) * video.width + floor(cx+dx)) * 4;
                    sumR+=video.pixels[i]; sumG+=video.pixels[i+1]; sumB+=video.pixels[i+2];
                    count++;
                }
            }
            if (count === 0) return null;
            return rgbToYCbCr(sumR/count, sumG/count, sumB/count);
        }
        
        function drawCalibrationGuide() {
            rectMode(CENTER); noFill(); stroke(255); strokeWeight(5);
            rect(width/2, height/2, 150, 150);
            
            video.loadPixels();
            if(video.pixels.length > 0) {
                let cx = video.width / 2; let cy = video.height / 2;
                let i = (Math.floor(cy) * video.width + Math.floor(cx)) * 4;
                fill(video.pixels[i], video.pixels[i+1], video.pixels[i+2]);
                stroke(255); strokeWeight(2);
                rect(width/2, height/2 - 120, 60, 60);
            }
        }

        function updateGameLogic() {
            if (frameCount % 60 === 0) {
                if (gameState === 'GAME' && timeLeft > 0) timeLeft--;
                if ((gameState === 'EXTRA1' || gameState === 'EXTRA2') && extraTimer > 0) extraTimer--;
            }
            // 遷移
            if (gameState === 'GAME') {
                if (timeLeft <= 20 && !waterSpawned && !hasCollectedWater) { spawnWater(); waterSpawned = true; }
                if (timeLeft <= 0) {
                    if (hasCollectedWater) {
                        gameState = 'WARNING'; warningTextX = width;
                        stopBGM(); if(soundLoaded.extra) { bgmExtra1.setVolume(0.5); bgmExtra1.loop(); }
                    } else { endGame(); }
                }
            } else if (gameState === 'EXTRA1' && extraTimer <= 0) {
                startExtraStage2();
            } else if (gameState === 'EXTRA2') {
                if (bossIsDead && extraTimer <= 0) endGame();
                else if (!bossIsDead && extraTimer <= 0) endGame();
            }
            // 敵スポーン
            if (frameCount % 60 === 0) {
                if(gameState === 'GAME') spawnBalloon('NORMAL');
                if(gameState === 'EXTRA1') spawnBalloon('EXTRA');
            }
            
            handleKamehameha();
            updateBalloons();
            updateFloatingTexts();
            if (gameState === 'EXTRA2') updateBoss();
        }

        function spawnWater() {
            balloons.push({
                type: 'WATER', x: random(100, width-100), y: height + 50,
                r: 80, w: 200, speed: 4, c: color(0, 100, 255)
            });
        }
        function startExtraStage2() {
            gameState = 'EXTRA2'; balloons = []; extraTimer = 15;
            boss = { x: width/2, y: height*0.6, w: width*0.8, hp: 2, justHit: false };
            bossIsDead = false;
            stopBGM(); if(soundLoaded.boss) { bgmBoss.setVolume(0.5); bgmBoss.loop(); }
        }

        function updateBalloons() {
            if (!isFiring && gameState !== 'EXTRA2' && frameCount % 30 === 0) spawnBalloon();
            for (let i = balloons.length - 1; i >= 0; i--) {
                let b = balloons[i];
                b.y -= b.speed;
                let hit = false;
                if (isFiring) hit = true;
                else {
                    for (let p of trackedPos) {
                        if (p && dist(p.x, p.y, b.x, b.y) < b.r + 50) hit = true;
                    }
                }
                if (hit) popBalloon(i);
                else if (b.y < -b.r) balloons.splice(i, 1);
            }
        }

        function spawnBalloon(mode) {
            // ★サイズを大きく
            if (gameState === 'GAME') {
                balloons.push({ type: 'NORMAL', x: random(50, width-50), y: height+50, r: 60, w: 150, c: color(random(255),255,255), speed: random(3, 7) });
            } else if (gameState === 'EXTRA1') {
                let type = random() < 0.5 ? 'GASHIMA' : 'IGONERI';
                balloons.push({ type: type, x: random(50, width-50), y: height+50, r: 60, w: 180, c: color(255), speed: random(6, 10) });
            }
        }

        function popBalloon(i) {
            let b = balloons[i];
            let pts = 10;
            if (b.type === 'WATER') { pts = 332; hasCollectedWater = true; addFloatingText("332", b.x, b.y); }
            else if (b.type !== 'NORMAL') { pts = 15; addFloatingText("15", b.x, b.y); }
            score += pts;
            balloons.splice(i, 1);
            osc.freq(random(500, 1000)); osc.amp(0.3, 0.05); setTimeout(()=>osc.amp(0, 0.05), 100);
        }

        function updateBoss() {
            if (!boss || bossIsDead) return;
            boss.y = height*0.6 + sin(frameCount * 0.05) * 20;
            if (isFiring && !boss.justHit) {
                boss.hp--; boss.justHit = true;
                if (boss.hp <= 0) {
                    score += 31000000000; bossIsDead = true; extraTimer = 3;
                    noiseOsc.amp(1.0, 0.1); setTimeout(()=>noiseOsc.amp(0, 1.0), 1000);
                    stopBGM(); if(soundLoaded.win) { bgmVictory.setVolume(1.0); bgmVictory.play(); }
                    addFloatingText("310億", width/2, height/2);
                } else {
                    addFloatingText("あと1回！", width/2, boss.y);
                    osc.freq(100); osc.amp(0.8, 0.05); setTimeout(()=>osc.amp(0, 0.05), 200);
                }
            } else if (!isFiring) boss.justHit = false;
        }

        function drawGameObjects() {
            for (let b of balloons) {
                let img = null;
                if(b.type === 'WATER') img = imgWater;
                else if(b.type === 'GASHIMA') img = imgEnemy1;
                else if(b.type === 'IGONERI') img = imgEnemy2;
                
                if(img && img.width > 1) {
                    imageMode(CENTER);
                    let h = b.w * IMG_RATIO;
                    image(img, b.x, b.y, b.w, h);
                } else {
                    fill(b.c); stroke(255); circle(b.x, b.y, b.r*2);
                }
            }
            if(gameState === 'EXTRA2' && boss) {
                let img = bossIsDead ? imgBossEnd : imgBoss;
                if(img && img.width > 1) {
                    imageMode(CENTER);
                    let h = boss.w * IMG_RATIO;
                    image(img, boss.x, boss.y, boss.w, h);
                } else {
                    fill(100); rect(boss.x, boss.y, boss.w, boss.w);
                }
            }
            if(isFiring) {
                push(); rectMode(CORNER); noStroke(); fill(255, 255, 0, 150); 
                rect(0, 0, width, height);
                pop();
            }
            for (let ft of floatingTexts) {
                push(); textAlign(CENTER, CENTER); textStyle(BOLD);
                if (ft.val === "310億") {
                    textSize(min(width,height)*0.15); fill(255, 215, 0); stroke(255,0,0); strokeWeight(8);
                } else {
                    textSize(40); fill(255, 255, 0); stroke(0); strokeWeight(3);
                }
                text(ft.val, ft.x, ft.y);
                pop();
            }
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                floatingTexts[i].life--; floatingTexts[i].y -= 1;
                if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
            }
        }
        function addFloatingText(val, x, y) { floatingTexts.push({val: val, x: x, y: y, life: 60}); }

        function handleKamehameha() {
            if (isFiring) {
                fireTimer--;
                if (fireTimer <= 0) { isFiring = false; needsSeparation = true; }
                return;
            }
            if (trackedPos[0] && trackedPos[1]) {
                let d = dist(trackedPos[0].x, trackedPos[0].y, trackedPos[1].x, trackedPos[1].y);
                if (needsSeparation) {
                    stroke(0, 0, 50); strokeWeight(4); line(trackedPos[0].x, trackedPos[0].y, trackedPos[1].x, trackedPos[1].y);
                    if (d > width*0.3) needsSeparation = false;
                    return; 
                }
                stroke(0, 0, 100, 150); strokeWeight(10); line(trackedPos[0].x, trackedPos[0].y, trackedPos[1].x, trackedPos[1].y);
                if (d < width*0.2) {
                    isCharging = true; chargeTimer += 2;
                    let cx = (trackedPos[0].x + trackedPos[1].x)/2; let cy = (trackedPos[0].y + trackedPos[1].y)/2;
                    noFill(); stroke(180, 100, 100); strokeWeight(random(5, 15));
                    circle(cx, cy, map(chargeTimer, 0, 60, 20, width*0.5));
                    osc.freq(map(chargeTimer, 0, 60, 200, 800)); 
                    if (chargeTimer > 60) {
                        isCharging = false; chargeTimer = 0; isFiring = true; fireTimer = 60;
                        osc.amp(0, 0.1); noiseOsc.amp(0.8, 0.1);
                    }
                } else {
                    chargeTimer = 0; isCharging = false;
                }
            }
        }

        function drawGameUI() {
            push();
            textAlign(LEFT, TOP); textSize(30); textStyle(BOLD);
            fill(0, 255, 255); text("SCORE: " + score.toLocaleString(), 30, 30);
            textAlign(RIGHT, TOP);
            let t = (gameState === 'EXTRA1' || gameState === 'EXTRA2') ? extraTimer : timeLeft;
            fill(0, 255, 0); text("TIME: " + t, width-30, 30);

            document.getElementById('charge-bar-container').style.display = 'block';
            let bar = document.getElementById('charge-bar');
            if (needsSeparation) { bar.style.width='100%'; bar.style.background='blue'; }
            else if (isCharging) { bar.style.width=map(chargeTimer,0,60,0,100)+'%'; bar.style.background='orange'; }
            else { bar.style.width='0%'; }
            pop();
        }

        function drawWarning() {
            background(0, 0, 0, 20); 
            fill(255, 0, 0); stroke(255); strokeWeight(5);
            textSize(80); textStyle(BOLD); textAlign(LEFT, CENTER);
            text("WARNING!! EXTRA STAGE!!", warningTextX, height/2);
            warningTextX -= 30; 
            if (warningTextX < -2000) startExtraStage1();
        }

        let countdownVal = 3;
        function drawCountdown() {
            if (frameCount % 60 === 0 && countdownVal > 0) countdownVal--;
            fill(0,0,0,100); rect(0,0,width,height);
            fill(60, 100, 100); textAlign(CENTER, CENTER); textSize(150);
            textStyle(BOLD); stroke(0, 100, 100); strokeWeight(20);
            if (countdownVal > 0) text(countdownVal, width/2, height/2);
            else {
                text("スタート！", width/2, height/2);
                if (frameCount % 60 === 30) { 
                    gameState = 'GAME'; score = 0; timeLeft = 60; balloons = [];
                    hasCollectedWater = false; waterSpawned = false; bossIsDead = false;
                    stopBGM(); if(soundLoaded.normal) { bgmNormal.setVolume(0.5); bgmNormal.loop(); }
                }
            }
        }

        // --- 画面遷移 ---
        function showScreen(id) {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('calibration-screen').style.display = 'none';
            document.getElementById('result-screen').style.display = 'none';
            document.getElementById('charge-bar-container').style.display = 'none';
            if(id) document.getElementById(id).style.display = 'flex';
            if(id === 'charge-bar-container') document.getElementById(id).style.display = 'block';
        }

        function startCalibration() {
            ensureAudio();
            showScreen('calibration-screen');
            gameState = 'CALIBRATION';
            if(soundLoaded.normal) { bgmNormal.setVolume(0); bgmNormal.play(); setTimeout(()=>{bgmNormal.pause();}, 100); } // iOS音出し対策
        }

        function mousePressed(e) {
            if (e.target.tagName === 'BUTTON') return;
            if (gameState === 'CALIBRATION' && video) {
                video.loadPixels();
                targetYCbCr = getAverageYCbCr();
                if (targetYCbCr) {
                    showScreen('charge-bar-container');
                    gameState = 'COUNTDOWN'; countdownVal = 3;
                }
            }
        }

        function stopBGM() {
            if(soundLoaded.normal) bgmNormal.stop();
            if(soundLoaded.extra) bgmExtra1.stop();
            if(soundLoaded.boss) bgmBoss.stop();
            if(soundLoaded.win) bgmVictory.stop();
        }

        function endGame() { 
            gameState = 'RESULT'; stopBGM();
            document.getElementById('result-title').innerText = bossIsDead ? "完全クリア！" : "タイムアップ";
            document.getElementById('final-score').innerText = score.toLocaleString();
            showScreen('result-screen');
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('kamehameha_highscore', highScore);
                updateScoreLabels();
            }
        }

        function returnToTitle() { 
            gameState = 'TITLE'; stopBGM();
            showScreen('title-screen');
            targetYCbCr = null; balloons = []; boss = null; hasCollectedWater = false;
        }

        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>